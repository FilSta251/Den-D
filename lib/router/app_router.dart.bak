// lib/router/app_router.dart

import 'package:flutter/material.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:firebase_performance/firebase_performance.dart';
import 'dart:collection';
import '../di/service_locator.dart';
import '../services/crash_reporting_service.dart';
import '../repositories/user_repository.dart';

// NOVĂ‰ IMPORTY - CHYBOVĂ‰ KOMPONENTY
import '../widgets/error_dialog.dart';
import '../widgets/custom_error_widget.dart';
import '../utils/global_error_handler.dart';
import 'package:den_d/widgets/error_dialog.dart' as ed;

// Import obrazovek
import '../screens/splash_screen.dart';
//import '../screens/welcome_screen.dart';
import '../screens/auth_screen.dart';
import '../screens/app_introduction_screen.dart';
import '../screens/chatbot_screen.dart';
import '../screens/bride_groom_main_menu.dart';
import '../screens/home_screen.dart';
import '../screens/checklist_screen.dart';
import '../screens/guests_screen.dart';
import '../screens/budget_screen.dart';
import '../screens/profile_page.dart';
import '../screens/wedding_info_page.dart';
import '../screens/subscription_page.dart';
import '../screens/legal_information_page.dart';
import '../screens/messages_page.dart';
import '../screens/settings_page.dart';
import '../screens/calendar_page.dart';
import '../screens/suppliers_list_page.dart';
import '../screens/usage_selection_screen.dart';
import '../screens/wedding_schedule_screen.dart';

/// CentralizovanĂˇ definice nĂˇzvĹŻ tras.
class AppRoutes {
  // PrimĂˇrnĂ­ obrazovky
  static const String splash = '/';
  //static const String welcome = '/welcome';
  static const String auth = '/auth';
  static const String onboarding = '/onboarding';
  static const String introduction = '/introduction';
  static const String usageSelection = '/usageSelection';

  // HlavnĂ­ obrazovky
  static const String main = '/main';
  static const String home = '/home';
  static const String brideGroomMain = '/brideGroomMain';

  // FunkčŤnĂ­ obrazovky
  static const String checklist = '/checklist';
  static const String budget = '/budget';
  static const String guests = '/guests';
  static const String suppliers = '/suppliers';
  static const String calendar = '/calendar';
  static const String weddingSchedule = '/weddingSchedule';

  // NastavenĂ­ a profil
  static const String profile = '/profile';
  static const String settings = '/settings';
  static const String weddingInfo = '/weddingInfo';
  static const String subscription = '/subscription';
  static const String legal = '/legal';

  // Komunikace
  static const String messages = '/messages';
  static const String chatbot = '/chatbot';
  static const String aiChat = '/aiChat';

  // Kategorizace tras podle priority
  static final Set<String> _criticalRoutes = {
    splash,
    auth,
    main,
    brideGroomMain,
    home
  };

  static final Set<String> _heavyRoutes = {
    budget,
    guests,
    weddingSchedule,
    suppliers
  };

  // NOVĂ‰: Trasy nĂˇchylnĂ© k chybĂˇm (potĹ™ebujĂ­ extra error handling)
  static final Set<String> _errorProneRoutes = {
    budget,
    guests,
    weddingSchedule,
    subscription,
    auth,
  };

  // ZnemoĹľněnĂ­ vytvoĹ™enĂ­ instance tĂ©to tĹ™Ă­dy
  AppRoutes._();

  /// Kontroluje, zda je trasa kritickĂˇ (nemĂˇ bĂ˝t cachovĂˇna)
  static bool isCriticalRoute(String routeName) =>
      _criticalRoutes.contains(routeName);

  /// Kontroluje, zda je trasa nĂˇročŤnĂˇ (mĂˇ bĂ˝t prefetchovĂˇna)
  static bool isHeavyRoute(String routeName) =>
      _heavyRoutes.contains(routeName);

  /// NOVĂ‰: Kontroluje, zda je trasa nĂˇchylnĂˇ k chybĂˇm
  static bool isErrorProneRoute(String routeName) =>
      _errorProneRoutes.contains(routeName);
}

/// CentralizovanĂˇ tĹ™Ă­da pro sprĂˇvu navigace v aplikaci.
///
/// Poskytuje metody pro generovĂˇnĂ­ rout, sprĂˇvu navigačŤnĂ­ho cache
/// a analytiku navigace.
class AppRouter {
  // Cache pro jiĹľ vytvoĹ™enĂ© widgety s LRU mechanismem
  static final LRUCache<String, Widget> _widgetCache =
      LRUCache<String, Widget>(maxSize: 10);

  // AktivnĂ­ trace pro měĹ™enĂ­ vĂ˝konu
  static final Map<String, Trace> _activeTraces = {};

  // Instance sluĹľby pro hlĂˇĹˇenĂ­ chyb
  static CrashReportingService? _crashReporting;

  // NOVĂ‰: PočŤĂ­tadlo chyb pro jednotlivĂ© trasy
  static final Map<String, int> _routeErrorCounts = {};

  // NOVĂ‰: MaximĂˇlnĂ­ počŤet chyb pĹ™ed fallback routou
  static const int _maxErrorsPerRoute = 3;

  /// Inicializace routeru
  static void initialize() {
    try {
      _crashReporting = locator<CrashReportingService>();

      // Inicializace globĂˇlnĂ­ho error handleru pro router
      GlobalErrorHandler.instance.setErrorCallback((AppError error) {
        _handleRouterError(error);
      });

      debugPrint('AppRouter inicializovĂˇn s error handling');
    } catch (e) {
      debugPrint(
          'VarovĂˇnĂ­: CrashReportingService nenĂ­ dostupnĂ˝, navigace nebude měĹ™ena');
    }
  }

  /// NOVĂ‰: Handling chyb specifickĂ˝ch pro router
  static void _handleRouterError(AppError error) {
    debugPrint('Router error: ${error.message}');

    // Zde mĹŻĹľete pĹ™idat specifickou logiku pro router chyby
    // napĹ™. pĹ™esměrovĂˇnĂ­ na bezpečŤnou obrazovku pĹ™i opakovanĂ˝ch chybĂˇch
  }

  /// Generuje route na zĂˇkladě poĹľadovanĂ© cesty.
  /// ROZĹ ĂŤĹENO o lepĹˇĂ­ error handling
  static Route<dynamic> generateRoute(RouteSettings settings) {
    // SpuĹˇtěnĂ­ měĹ™enĂ­ vĂ˝konu navigace
    final String routeName = settings.name ?? 'unknown';
    _startNavigationTrace(routeName);

    // ZaznamenĂˇnĂ­ navigace do analytiky a jako breadcrumb
    _logNavigation(settings);

    try {
      // NOVĂ‰: Kontrola počŤtu chyb pro tuto trasu
      final errorCount = _routeErrorCounts[routeName] ?? 0;
      if (errorCount >= _maxErrorsPerRoute) {
        _stopNavigationTrace(routeName);
        return _createFallbackRoute(
            routeName, 'PĹ™Ă­liĹˇ mnoho chyb pro tuto obrazovku');
      }

      // VytvoĹ™enĂ­ widgetu pro poĹľadovanou cestu
      final Widget widget = _resolveWidget(settings);

      // NOVĂ‰: ObalenĂ­ error-prone tras do ErrorBoundary
      final Widget wrappedWidget = AppRoutes.isErrorProneRoute(routeName)
          ? _wrapWithErrorBoundary(widget, routeName)
          : widget;

      // UkončŤenĂ­ měĹ™enĂ­ vĂ˝konu
      _stopNavigationTrace(routeName);

      // Volba typu animace a vytvoĹ™enĂ­ route
      return _createRoute(settings, wrappedWidget);
    } catch (e, stack) {
      // NOVĂ‰: PočŤĂ­tĂˇnĂ­ chyb pro trasu
      _routeErrorCounts[routeName] = (_routeErrorCounts[routeName] ?? 0) + 1;

      // ZachycenĂ­ a zaznamenĂˇnĂ­ chyby
      _logNavigationError(e, stack, routeName);

      // PouĹľitĂ­ globĂˇlnĂ­ho error handleru
      GlobalErrorHandler.instance.handleError(
        e,
        stackTrace: stack,
        type: ed.ErrorType.critical,
        userMessage: 'Chyba pĹ™i načŤĂ­tĂˇnĂ­ obrazovky $routeName',
        errorCode: 'ROUTE_ERROR_${routeName.toUpperCase()}',
      );

      // UkončŤenĂ­ měĹ™enĂ­ vĂ˝konu
      _stopNavigationTrace(routeName);

      // VytvoĹ™enĂ­ chybovĂ© route s naĹˇimi komponentami
      return _errorRoute(routeName, e.toString());
    }
  }

  /// NOVĂ‰: ObalenĂ­ widgetu do ErrorBoundary
  static Widget _wrapWithErrorBoundary(Widget widget, String routeName) {
    return ErrorBoundary(
      child: widget,
      onError: (error, stackTrace) {
        GlobalErrorHandler.instance.handleError(
          error,
          stackTrace: stackTrace,
          type: ed.ErrorType.critical,
          userMessage: 'Chyba na obrazovce $routeName',
          errorCode: 'SCREEN_ERROR_${routeName.toUpperCase()}',
        );
      },
      errorBuilder: (error) => CustomErrorWidget(
        message: 'Chyba na obrazovce',
        errorType: ErrorWidgetType.unknown,
        onRetry: () {
          // Reset error count a pokus o reload
          _routeErrorCounts[routeName] = 0;
        },
        detailMessage:
            'DoĹˇlo k chybě na obrazovce $routeName: ${error.toString()}',
      ),
    );
  }

  /// VytvoĹ™Ă­ route s animacĂ­ fade transition
  static Route<dynamic> _createRoute(RouteSettings settings, Widget widget) {
    // RozhodnutĂ­, zda pouĹľĂ­t animaci nebo ne
    final bool useAnimation = !AppRoutes.isCriticalRoute(settings.name ?? '');

    if (useAnimation) {
      return PageRouteBuilder(
        settings: settings,
        pageBuilder: (context, animation, secondaryAnimation) => widget,
        transitionsBuilder: (context, animation, secondaryAnimation, child) {
          return FadeTransition(opacity: animation, child: child);
        },
        transitionDuration: const Duration(milliseconds: 300),
      );
    } else {
      // Pro kritickĂ© obrazovky pĹ™eskočŤĂ­me animaci
      return MaterialPageRoute(
        settings: settings,
        builder: (context) => widget,
      );
    }
  }

  /// Rozhodne, zda pouĹľĂ­t cachovanĂ˝ widget nebo vytvoĹ™it novĂ˝
  static Widget _resolveWidget(RouteSettings settings) {
    final String routeName = settings.name ?? 'unknown';

    // Pro kritickĂ© trasy vĹľdy vytvoĹ™Ă­me novou instanci
    if (AppRoutes.isCriticalRoute(routeName)) {
      return _createWidgetForRoute(settings);
    }

    // Pro ostatnĂ­ trasy se podĂ­vĂˇme do cache
    if (_widgetCache.containsKey(routeName)) {
      debugPrint('PouĹľitĂ­ cached widgetu pro $routeName');
      return _widgetCache.get(routeName)!;
    }

    // VytvoĹ™enĂ­ a cachovĂˇnĂ­ novĂ© instance
    final Widget widget = _createWidgetForRoute(settings);
    _widgetCache.put(routeName, widget);
    return widget;
  }

  /// VytvoĹ™Ă­ widget pro danou cestu a jejĂ­ argumenty
  /// ROZĹ ĂŤĹENO o error handling pro jednotlivĂ© obrazovky
  static Widget _createWidgetForRoute(RouteSettings settings) {
    final arguments = settings.arguments;

    try {
      switch (settings.name) {
        case AppRoutes.splash:
          return const SplashScreen();
        //case AppRoutes.welcome:
        //return const WelcomeScreen();
        case AppRoutes.auth:
          return AuthScreen(userRepository: locator<UserRepository>());
        case AppRoutes.introduction:
          return const AppIntroductionScreen();
        case AppRoutes.usageSelection:
          return const UsageSelectionScreen();
        case AppRoutes.chatbot:
          return const ChatBotScreen();
        case AppRoutes.main:
          return const BrideGroomMainMenu();
        case AppRoutes.brideGroomMain:
          return const BrideGroomMainMenu();
        case AppRoutes.profile:
          return const ProfilePage();
        case AppRoutes.weddingInfo:
          return const WeddingInfoPage();
        case AppRoutes.weddingSchedule:
          return const WeddingScheduleScreen();
        case AppRoutes.subscription:
          return const SubscriptionPage();
        case AppRoutes.legal:
          // PĹ™edĂˇnĂ­ argumentu pro pĹ™epĂ­načŤ terms/privacy
          final String contentType = (arguments as String?) ?? 'terms';
          return LegalInformationPage(contentType: contentType);
        case AppRoutes.messages:
          return const MessagesPage();
        case AppRoutes.settings:
          return const SettingsPage();
        case AppRoutes.checklist:
          return const ChecklistPage();
        case AppRoutes.calendar:
          return const CalendarPage();
        case AppRoutes.aiChat:
          return const HomeScreen();
        case AppRoutes.suppliers:
          return const SuppliersListPage();
        case AppRoutes.guests:
          return const GuestsScreen();
        case AppRoutes.budget:
          return const BudgetScreen();
        case AppRoutes.home:
          return const HomeScreen();
        default:
          throw RouteNotFoundException('NeznĂˇmĂˇ cesta: ${settings.name}');
      }
    } catch (e, stack) {
      // SpecifickĂ© handlovĂˇnĂ­ chyb pro vytvĂˇĹ™enĂ­ widgetĹŻ
      GlobalErrorHandler.instance.handleError(
        e,
        stackTrace: stack,
        type: ed.ErrorType.critical,
        userMessage: 'Chyba pĹ™i vytvĂˇĹ™enĂ­ obrazovky ${settings.name}',
        errorCode: 'WIDGET_CREATION_ERROR',
      );

      // Fallback widget s error komponentou
      return CustomErrorWidget(
        message: 'Chyba pĹ™i načŤĂ­tĂˇnĂ­ obrazovky',
        errorType: ErrorWidgetType.unknown,
        onRetry: () {
          // VyčŤistit cache a zkusit znovu
          _widgetCache.remove(settings.name ?? '');
        },
        detailMessage:
            'Obrazovka ${settings.name} se nepodaĹ™ila načŤĂ­st: ${e.toString()}',
      );
    }
  }

  /// NOVĂ‰: Metody pro navigaci na subscription strĂˇnky
  static void navigateToSubscription(BuildContext context) {
    Navigator.of(context).pushNamed(AppRoutes.subscription);
  }

  static void navigateToTerms(BuildContext context) {
    Navigator.of(context).pushNamed(AppRoutes.legal, arguments: 'terms');
  }

  static void navigateToPrivacy(BuildContext context) {
    Navigator.of(context).pushNamed(AppRoutes.legal, arguments: 'privacy');
  }

  /// NOVĂ‰: Metoda pro navigaci z paywallu
  static void navigateFromPaywall(BuildContext context, {String? source}) {
    Navigator.of(context).pushNamed(
      AppRoutes.subscription,
      arguments: {'source': source ?? 'paywall'},
    );
  }

  /// NOVĂ‰: Metoda pro navigaci z onboardingu
  static void navigateFromOnboarding(BuildContext context) {
    Navigator.of(context).pushNamed(
      AppRoutes.subscription,
      arguments: {'source': 'onboarding'},
    );
  }

  /// NOVĂ‰: VytvoĹ™Ă­ fallback route pĹ™i pĹ™Ă­liĹˇ mnoha chybĂˇch
  static Route<dynamic> _createFallbackRoute(String routeName, String reason) {
    return MaterialPageRoute(
      builder: (context) => Scaffold(
        appBar: AppBar(
          title: const Text('Obrazovka nedostupnĂˇ'),
          backgroundColor: Colors.orange,
        ),
        body: CustomErrorWidget(
          message: 'Obrazovka dočŤasně nedostupnĂˇ',
          errorType: ErrorWidgetType.maintenance,
          onRetry: () {
            // Reset error count
            _routeErrorCounts[routeName] = 0;
            Navigator.of(context).pushReplacementNamed(routeName);
          },
          onSecondaryAction: () {
            Navigator.of(context).pushNamedAndRemoveUntil(
              AppRoutes.home,
              (route) => false,
            );
          },
          secondaryActionText: 'DomĹŻ',
          secondaryActionIcon: Icons.home,
          detailMessage:
              'Obrazovka $routeName byla dočŤasně zakĂˇzĂˇna kvĹŻli opakovanĂ˝m chybĂˇm. DĹŻvod: $reason',
          showReportButton: true,
          onReportError: () {
            // Zobrazit error dialog pro report
            ErrorDialog.show(
              context,
              title: 'NahlĂˇsit problĂ©m',
              message:
                  'Chcete nahlĂˇsit opakovanĂ© problĂ©my s obrazovkou $routeName?',
              errorType: ed.ErrorType.critical,
              errorCode: 'REPEATED_ROUTE_ERRORS',
              technicalDetails:
                  'Route: $routeName\nError count: ${_routeErrorCounts[routeName]}\nReason: $reason',
              recoveryActions: [RecoveryAction.contact, RecoveryAction.ignore],
              onRecoveryAction: (action) {
                if (action == RecoveryAction.contact) {
                  // Implementace kontaktu
                  debugPrint('Reporting repeated errors for route: $routeName');
                }
              },
            );
          },
        ),
      ),
    );
  }

  /// VytvoĹ™Ă­ chybovou route s naĹˇimi error komponentami
  /// AKTUALIZOVĂNO pro pouĹľitĂ­ naĹˇich komponent
  static Route<dynamic> _errorRoute(String path, String errorMessage) {
    return MaterialPageRoute(
      builder: (context) => Scaffold(
        appBar: AppBar(
          title: const Text('Chyba navigace'),
          backgroundColor: Colors.red,
        ),
        body: CustomErrorWidget(
          message: 'StrĂˇnka nenalezena',
          errorType: ErrorWidgetType.notFound,
          onRetry: () {
            Navigator.of(context)
                .pushNamedAndRemoveUntil(AppRoutes.splash, (route) => false);
          },
          onSecondaryAction: () {
            Navigator.of(context).pushNamedAndRemoveUntil(
              AppRoutes.home,
              (route) => false,
            );
          },
          secondaryActionText: 'DomĹŻ',
          secondaryActionIcon: Icons.home,
          detailMessage: 'Cesta: $path\nDetaily: $errorMessage',
          showReportButton: true,
          onReportError: () {
            ErrorDialog.show(
              context,
              title: 'NahlĂˇsit chybu navigace',
              message: 'Chcete nahlĂˇsit problĂ©m s navigacĂ­?',
              errorType: ed.ErrorType.critical,
              errorCode: 'NAVIGATION_ERROR',
              technicalDetails: 'Path: $path\nError: $errorMessage',
              recoveryActions: [RecoveryAction.contact, RecoveryAction.ignore],
            );
          },
        ),
      ),
    );
  }

  /// ZahĂˇjenĂ­ měĹ™enĂ­ vĂ˝konu navigace
  static void _startNavigationTrace(String routeName) {
    try {
      // VytvoĹ™enĂ­ a spuĹˇtěnĂ­ trace
      final String traceName = 'navigation_${routeName.replaceAll("/", "_")}';
      final trace = FirebasePerformance.instance.newTrace(traceName);
      trace.start();
      _activeTraces[routeName] = trace;
    } catch (e) {
      debugPrint('Chyba pĹ™i zahĂˇjenĂ­ měĹ™enĂ­ navigace: $e');
      GlobalErrorHandler.instance.handleError(
        e,
        type: ed.ErrorType.unknown,
        userMessage: 'Chyba pĹ™i měĹ™enĂ­ vĂ˝konu navigace',
        errorCode: 'NAVIGATION_TRACE_START_ERROR',
      );
    }
  }

  /// UkončŤenĂ­ měĹ™enĂ­ vĂ˝konu navigace
  static void _stopNavigationTrace(String routeName) {
    try {
      if (_activeTraces.containsKey(routeName)) {
        final trace = _activeTraces[routeName]!;
        trace.stop();
        _activeTraces.remove(routeName);
      }
    } catch (e) {
      debugPrint('Chyba pĹ™i ukončŤenĂ­ měĹ™enĂ­ navigace: $e');
      GlobalErrorHandler.instance.handleError(
        e,
        type: ed.ErrorType.unknown,
        userMessage: 'Chyba pĹ™i ukončŤenĂ­ měĹ™enĂ­ vĂ˝konu',
        errorCode: 'NAVIGATION_TRACE_STOP_ERROR',
      );
    }
  }

  /// ZaznamenĂˇnĂ­ navigace do analytiky
  static void _logNavigation(RouteSettings settings) {
    try {
      // ZĂ­skĂˇnĂ­ informacĂ­ o odkud a kam navigujeme
      String? fromScreen;
      if (settings.arguments is Map<String, dynamic>) {
        fromScreen = (settings.arguments as Map<String, dynamic>)['from_screen']
            as String?;
      }

      // ZaznamenĂˇnĂ­ do analytiky (pokud je dostupnĂˇ)
      try {
        // final analytics = locator<AnalyticsService>();
        // analytics.logScreenView(screenName: settings.name ?? 'unknown');
      } catch (_) {
        // Analytika nemusĂ­ bĂ˝t dostupnĂˇ
      }

      // ZaznamenĂˇnĂ­ jako breadcrumb (pokud je dostupnĂˇ sluĹľba)
      if (_crashReporting != null) {
        _crashReporting!.addBreadcrumb(
          message: 'Navigace na obrazovku',
          category: 'navigation',
          data: {
            'to_screen': settings.name,
            'from_screen': fromScreen,
            'arguments': settings.arguments?.toString(),
            'error_count': _routeErrorCounts[settings.name ?? 'unknown'] ?? 0,
          },
        );
      }
    } catch (e) {
      debugPrint('Chyba pĹ™i logovĂˇnĂ­ navigace: $e');
      GlobalErrorHandler.instance.handleError(
        e,
        type: ed.ErrorType.unknown,
        userMessage: 'Chyba pĹ™i zaznamenĂˇnĂ­ navigace',
        errorCode: 'NAVIGATION_LOG_ERROR',
      );
    }
  }

  /// ZaznamenĂˇnĂ­ chyby navigace
  static void _logNavigationError(
      Object error, StackTrace? stackTrace, String routeName) {
    debugPrint('Chyba pĹ™i navigaci na $routeName: $error');

    // ZaznamenĂˇnĂ­ do Crashlytics
    try {
      FirebaseCrashlytics.instance.recordError(
        error,
        stackTrace,
        reason: 'Navigation to $routeName failed',
        printDetails: true,
      );
    } catch (_) {
      // Crashlytics nemusĂ­ bĂ˝t dostupnĂ©
    }

    // ZaznamenĂˇnĂ­ do rozĹˇĂ­Ĺ™enĂ©ho systĂ©mu hlĂˇĹˇenĂ­ chyb
    if (_crashReporting != null) {
      _crashReporting!.recordErrorWithContext(
          error.toString(), 'navigation', stackTrace,
          additionalData: {
            'route': routeName,
            'error_count': _routeErrorCounts[routeName] ?? 0,
          });
    }
  }

  /// VyčŤiĹˇtěnĂ­ cache
  static void clearCache() {
    _widgetCache.clear();
    // NOVĂ‰: Reset error counts
    _routeErrorCounts.clear();
    debugPrint('Router cache a error counts byly vyčŤiĹˇtěny');
  }

  /// NOVĂ‰: Reset error count pro specifickou trasu
  static void resetRouteErrorCount(String routeName) {
    _routeErrorCounts.remove(routeName);
    debugPrint('Error count pro trasu $routeName byl resetovĂˇn');
  }

  /// NOVĂ‰: ZĂ­skĂˇnĂ­ počŤtu chyb pro trasu
  static int getRouteErrorCount(String routeName) {
    return _routeErrorCounts[routeName] ?? 0;
  }

  /// Prefetching těĹľkĂ˝ch obrazovek s error handlingem
  static void prefetchHeavyScreens() {
    debugPrint('ZahĂˇjenĂ­ prefetchingu těĹľkĂ˝ch obrazovek');

    // VytvoĹ™enĂ­ a uloĹľenĂ­ těĹľkĂ˝ch obrazovek do cache
    for (final route in AppRoutes._heavyRoutes) {
      try {
        final settings = RouteSettings(name: route);
        final widget = _createWidgetForRoute(settings);
        _widgetCache.put(route, widget);
        debugPrint('Prefetched obrazovka: $route');
      } catch (e, stack) {
        debugPrint('Chyba pĹ™i prefetchingu obrazovky $route: $e');
        GlobalErrorHandler.instance.handleError(
          e,
          stackTrace: stack,
          type: ed.ErrorType.unknown,
          userMessage: 'Chyba pĹ™i pĹ™edčŤĂ­tĂˇnĂ­ obrazovky $route',
          errorCode: 'PREFETCH_ERROR',
        );
      }
    }
  }
}

/// NOVĂ‰: Custom exception pro neznĂˇmĂ© trasy
class RouteNotFoundException implements Exception {
  final String message;
  RouteNotFoundException(this.message);

  @override
  String toString() => 'RouteNotFoundException: $message';
}

/// LRU (Least Recently Used) Cache implementace pro widgety
class LRUCache<K, V> {
  final int maxSize;
  final LinkedHashMap<K, V> _cache = LinkedHashMap<K, V>();

  LRUCache({required this.maxSize});

  /// Kontrola, zda klĂ­čŤ existuje v cache
  bool containsKey(K key) => _cache.containsKey(key);

  /// ZĂ­skĂˇnĂ­ hodnoty z cache
  V? get(K key) {
    if (!_cache.containsKey(key)) return null;

    // PĹ™esunutĂ­ hodnoty na konec mapy (označŤenĂ­ jako nedĂˇvno pouĹľitĂ©)
    final V value = _cache[key] as V;
    _cache.remove(key);
    _cache[key] = value;

    return value;
  }

  /// VloĹľenĂ­ hodnoty do cache
  void put(K key, V value) {
    // Pokud klĂ­čŤ jiĹľ existuje, nejprve ho odstranĂ­me
    if (_cache.containsKey(key)) {
      _cache.remove(key);
    }
    // Pokud je cache plnĂ˝, odstranĂ­me nejstarĹˇĂ­ poloĹľku
    else if (_cache.length >= maxSize) {
      _cache.remove(_cache.keys.first);
    }

    // PĹ™idĂˇnĂ­ novĂ© hodnoty
    _cache[key] = value;
  }

  /// OdstraněnĂ­ hodnoty z cache
  void remove(K key) {
    _cache.remove(key);
  }

  /// VyčŤiĹˇtěnĂ­ celĂ© cache
  void clear() {
    _cache.clear();
  }

  /// AktuĂˇlnĂ­ velikost cache
  int get size => _cache.length;
}
